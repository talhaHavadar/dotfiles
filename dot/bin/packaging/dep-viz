#!/usr/bin/env -S uv run --script
# /// script
# requires-python = ">=3.8"
# dependencies = [
#     "requests",
#     "graphviz",
# ]
# ///
"""Big thanks to https://github.com/hkhonming for sharing this tool with me.

This script can/may be changed to fit my needs. Please use with caution.
"""
import argparse
import requests
import gzip
import lzma
import re
import sys
from graphviz import Digraph


def fetch_repo_file(base_url, dist, path):
    """Fetches and decompresses a repository file (Packages or Sources)."""
    extensions = ["xz", "gz"]
    # Ensure URL ends with /
    if not base_url.endswith("/"):
        base_url += "/"

    for ext in extensions:
        url = f"{base_url}{path}.{ext}"
        try:
            print(f"[-] Attempting to fetch: {url}")
            response = requests.get(url, timeout=10)
            if response.status_code == 200:
                print(f"[+] Successfully fetched {url}")
                if ext == "xz":
                    return lzma.decompress(response.content).decode("utf-8")
                else:
                    return gzip.decompress(response.content).decode("utf-8")
        except Exception as e:
            print(f"[!] Connection error: {e}")
            continue

    print(f"[!] Error: Could not find or download file at {base_url}{path}")
    sys.exit(1)


def fetch_packages_file(base_url, dist, arch):
    """Fetches and decompresses the Packages file from the PPA."""
    base_path = f"dists/{dist}/main/binary-{arch}/Packages"
    return fetch_repo_file(base_url, dist, base_path)


def fetch_sources_file(base_url, dist):
    """Fetches and decompresses the Sources file from the PPA."""
    base_path = f"dists/{dist}/main/source/Sources"
    return fetch_repo_file(base_url, dist, base_path)


def parse_packages(content):
    """Parses the Packages file content into a list of dictionaries."""
    packages = []
    current_pkg = {}
    for line in content.splitlines():
        if line.strip() == "":
            if "Package" in current_pkg:
                packages.append(current_pkg)
            current_pkg = {}
            continue
        if ": " in line:
            key, value = line.split(": ", 1)
            current_pkg[key] = value.strip()

    # Capture the last package if the file doesn't end with a newline
    if "Package" in current_pkg:
        packages.append(current_pkg)
    return packages


def parse_sources(content):
    """Parses the Sources file content into a list of dictionaries.

    Handles multi-line fields (continuation lines starting with whitespace).
    """
    sources = []
    current_src = {}
    current_key = None

    for line in content.splitlines():
        if line.strip() == "":
            if "Package" in current_src:
                sources.append(current_src)
            current_src = {}
            current_key = None
            continue

        # Continuation line (starts with whitespace)
        if line.startswith(" ") or line.startswith("\t"):
            if current_key and current_key in current_src:
                current_src[current_key] += " " + line.strip()
            continue

        if ": " in line:
            key, value = line.split(": ", 1)
            current_src[key] = value.strip()
            current_key = key

    # Capture the last source if the file doesn't end with a newline
    if "Package" in current_src:
        sources.append(current_src)
    return sources


def get_source_name(pkg_info):
    """Extracts the Source package name."""
    if "Source" in pkg_info:
        return pkg_info["Source"].split(" ")[0].strip()
    return pkg_info["Package"]


def clean_dependency_name(dep_str):
    """Removes version constraints."""
    return re.sub(r"\s*\(.*?\)", "", dep_str).strip()


def get_build_depends(src_info):
    """Extracts Build-Depends from source package info (case-insensitive)."""
    # Check for Build-Depends (case-insensitive)
    for key in src_info:
        if key.lower() == "build-depends":
            return src_info[key]
    return ""


def build_binary_graph(packages):
    """Generates a graph based on Binary Package dependencies."""
    dot = Digraph(comment="PPA Binary Dependency Chart")
    dot.attr(rankdir="LR")
    dot.attr("node", shape="box", style="filled", fillcolor="lightblue")

    # Map of all binaries available in this PPA
    ppa_binaries = {p["Package"] for p in packages}

    # Track added nodes to avoid duplicates
    added_nodes = set()

    for pkg in packages:
        pkg_name = pkg["Package"]

        if pkg_name not in added_nodes:
            dot.node(pkg_name, pkg_name)
            added_nodes.add(pkg_name)

        depends_raw = pkg.get("Depends", "")
        if not depends_raw:
            continue

        for dep in depends_raw.split(","):
            dep = dep.strip()
            if not dep:
                continue
            if "|" in dep:
                dep = dep.split("|")[0].strip()

            target_bin = clean_dependency_name(dep)

            # ONLY draw if target is also in the PPA
            if target_bin in ppa_binaries:
                dot.edge(pkg_name, target_bin)

    return dot


def build_source_graph(sources):
    """Generates a graph based on Source Package Build-Depends."""
    dot = Digraph(comment="PPA Source Dependency Chart")
    dot.attr(rankdir="LR")
    dot.attr("node", shape="component", style="filled", fillcolor="#E0E0E0")

    # Map Binary -> Source (from the Binary field in Sources)
    bin_to_source_map = {}
    ppa_sources = set()

    for src in sources:
        src_name = src["Package"]
        ppa_sources.add(src_name)

        # The Binary field lists all binary packages built from this source
        binaries = src.get("Binary", "")
        for bin_name in binaries.split(","):
            bin_name = bin_name.strip()
            if bin_name:
                bin_to_source_map[bin_name] = src_name

    edges = set()

    for src in sources:
        src_from = src["Package"]
        build_depends_raw = get_build_depends(src)
        if not build_depends_raw:
            continue

        for dep in build_depends_raw.split(","):
            dep = dep.strip()
            if not dep:
                continue
            # Handle alternatives (pick first one)
            if "|" in dep:
                dep = dep.split("|")[0].strip()

            # Remove architecture qualifiers like :any, :native
            bin_target = clean_dependency_name(dep)
            if ":" in bin_target:
                bin_target = bin_target.split(":")[0]

            # Resolve target binary to target source
            # If bin_target is not in map, it's external (system) -> Skip
            if bin_target in bin_to_source_map:
                src_to = bin_to_source_map[bin_target]

                if src_from != src_to:
                    edges.add((src_from, src_to))

    for src in ppa_sources:
        dot.node(src, src)

    for src_from, src_to in edges:
        dot.edge(src_from, src_to)

    return dot


def main():
    parser = argparse.ArgumentParser(description="Generate PPA Dependency Charts")

    # Required Args
    parser.add_argument(
        "--ppa",
        required=True,
        help="The base URL of the PPA (e.g., https://ppa.../ubuntu/)",
    )

    # Optional Args with Defaults
    parser.add_argument(
        "--dist", default="noble", help="Distribution codename (default: noble)"
    )
    parser.add_argument("--arch", default="arm64", help="Architecture (default: arm64)")
    parser.add_argument(
        "--output",
        default="dependency_graph",
        help="Output filename (without extension)",
    )
    parser.add_argument(
        "--mode",
        choices=["binary", "source"],
        default="binary",
        help="Graph mode: 'binary' (package-to-package) or 'source' (aggregated by source)",
    )

    args = parser.parse_args()

    # 1. Fetch and Parse
    if args.mode == "binary":
        print(f"[*] Fetching Packages metadata for {args.dist}/{args.arch}...")
        content = fetch_packages_file(args.ppa, args.dist, args.arch)
        packages = parse_packages(content)
        print(f"[*] Found {len(packages)} binary packages.")

        # 2. Build Graph
        print("[*] Generating BINARY level dependency graph...")
        dot = build_binary_graph(packages)
    else:
        print(f"[*] Fetching Sources metadata for {args.dist}...")
        content = fetch_sources_file(args.ppa, args.dist)
        sources = parse_sources(content)
        print(f"[*] Found {len(sources)} source packages.")

        # 2. Build Graph
        print("[*] Generating SOURCE level dependency graph (using Build-Depends)...")
        dot = build_source_graph(sources)

    # 4. Render
    try:
        output_path = dot.render(args.output, format="png", cleanup=True)
        print(f"[SUCCESS] Chart saved to: {output_path}")
    except Exception as e:
        print(f"[!] Error rendering graph: {e}")
        print(
            "    Ensure 'graphviz' is installed on your system (e.g., 'sudo apt install graphviz')"
        )


if __name__ == "__main__":
    main()
